/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Wed Apr 14 2021 10:39:10 GMT-0500 (Central Daylight Time).
 * 
 * Copied from StateMachineJoint
 */

 define(['jointjs', 'css!./styles/SimPNWidget.css'], function (joint) {
    'use strict';

    var WIDGET_CLASS = 'sim-s-m';

    function SimPNWidget(logger, container) {
        
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this._logger.debug('ctor finished');
    }

    SimPNWidget.prototype._initialize = function () {
        console.log(joint);
        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);

        this._jointPN = new joint.dia.Graph;
        this._jointPaper = new joint.dia.Paper({
            el: this._el,
            width : width,
            height: height,
            model: this._jointPN,
            interactive: false
        });

        // add event calls to elements
        this._jointPaper.on('element:pointerdblclick', function(elementView) {
            const currentElement = elementView.model;
            // console.log(currentElement);
            if (self._webgmePN) {
                // console.log(self._webgmePN.id2state[currentElement.id]);
                self._setCurrentState(self._webgmePN.id2transitions[currentElement.id]);
            }
        });

        this._webgmePN = null;
    };

    SimPNWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');
    };

    // Petri Net manipulating functions called from the controller
    SimPNWidget.prototype.initPetri = function (petriDescriptor) {
        const self = this;
        console.log(petriDescriptor);

        self._webgmePN = petriDescriptor;
        self._webgmePN.current = self._webgmePN.init;
        self._jointPN.clear();
        const pn = self._webgmePN;
        pn.id2transitions = {}; // this dictionary will connect the on-screen id to the transition id
        pn.id2places = {}; // this dictionary will connect the on-screen id to the place id

        // first add the transitions
        Object.keys(pn.transitions).forEach(transitionId => {
            let tran = null;
            let count = 0;
            let color = 'green';
            let cursor = 'default';
            pn.transitions[transitionId].inPlaces.forEach(inPlaceId => {
                if(pn.places[inPlaceId].capacity == 0)
                    color = 'black';
                    cursor = 'pointer';
                count++;
            });
            if(count == 0) color = 'black';
            tran = new joint.shapes.standard.Rectangle({
                position: pn.transitions[transitionId].position,
                size: { width: 30, height: 120 },
                attrs: {
                    label : {
                        text: pn.transitions[transitionId].name,
                        //event: 'element:label:pointerdown',
                        fontWeight: 'bold',
                        cursor: cursor,
                        style: {
                            stroke: 'white',
                            fill: 'white'
                        }
                    },
                    body: {
                        fill: color,
                        strokeWidth: 3,
                        cursor: cursor
                    }
                }
            });
            
            tran.addTo(self._jointPN);
            pn.transitions[transitionId].joint = tran;
            pn.id2transitions[tran.id] = transitionId;
        });

        Object.keys(pn.places).forEach(placeId => {
            let place = null;
            let count = pn.places[placeId].capacity;
            place = new joint.shapes.standard.Circle({
                position: pn.places[placeId].position,
                size: { width: 100, height: 100 },
                attrs: {
                    label : {
                        text: pn.places[placeId].name,
                        //event: 'element:label:pointerdown',
                        fontWeight: 'bold',
                        //cursor: 'text',
                        //style: {
                        //    userSelect: 'text'
                        //}
                    },
                    body: {
                        strokeWidth: 3,
                        //cursor: 'pointer',
                        fillOpacity: 0
                    }
                }
            });
        
            place.addTo(self._jointPN);
            pn.places[placeId].joint = place;
            pn.id2places[place.id] = placeId;
        });

        

        // then create the arcs
        Object.keys(pn.transitions).forEach(tranId => {
            const tran = pn.transitions[tranId];
            Object.keys(tran.inPlaces).forEach(inPlace => {
                tran.jointNext = tran.jointNext || {};
                const link = new joint.shapes.standard.Link({
                    source: {id: pn.places[tran.inPlaces[inPlace]].joint.id},
                    target: {id: tran.joint.id},
                    attrs: {
                        line: {
                            strokeWidth: 2
                        },
                        wrapper: {
                            cursor: 'default'
                        }
                    },
                    labels: [{
                        position: {
                            distance: 0.5,
                            offset: 0,
                            args: {
                                keepGradient: true,
                                ensureLegibility: true
                            }
                        },
                        attrs: {
                        }
                    }]
                });
                link.addTo(self._jointPN);
                tran.jointNext[tran.inPlaces[inPlace]] = link;
            });
            Object.keys(tran.outPlaces).forEach(outPlace => {
                tran.jointNext = tran.jointNext || {};
                const link = new joint.shapes.standard.Link({
                    target: {id: pn.places[tran.outPlaces[outPlace]].joint.id},
                    source: {id: tran.joint.id},
                    attrs: {
                        line: {
                            strokeWidth: 2
                        },
                        wrapper: {
                            cursor: 'default'
                        }
                    },
                    labels: [{
                        position: {
                            distance: 0.5,
                            offset: 0,
                            args: {
                                keepGradient: true,
                                ensureLegibility: true
                            }
                        },
                        attrs: {
                        }
                    }]
                });
                link.addTo(self._jointPN);
                tran.jointNext[tran.outPlaces[outPlace]] = link;
            });
        });

        //now refresh the visualization
        self._jointPaper.updateViews();
        self._decoratePetri();
    };

    SimPNWidget.prototype.destroyPetri = function () {

    };

    SimPNWidget.prototype.fireEvent = function (event) {
        const self = this;
        const current = self._webgmePN.states[self._webgmePN.current];
        const link = current.jointNext[event];
        const linkView = link.findView(self._jointPaper);
        linkView.sendToken(joint.V('circle', { r: 10, fill: 'black' }), {duration:500}, function() {
           self._webgmePN.current = current.next[event];
           self._decoratePetri();
        });


    };

    SimPNWidget.prototype.resetPetri = function () {
        this._webgmePN.current = this._webgmePN.init;
        this._decoratePetri();
    };

    SimPNWidget.prototype._decoratePetri = function() {
        const pn = this._webgmePN;
        let count = 0;
        Object.keys(pn.transitions).forEach(tranId => {
            count = 0;
            pn.transitions[tranId].inPlaces.forEach(inPlaceId => {
                if(pn.places[inPlaceId].capacity == 0) count++;
            });
            if (count == 0) {
                pn.transitions[tranId].joint.attr('body/fill', 'green');
                pn.transitions[tranId].joint.attr('body/cursor', 'pointer');
                pn.transitions[tranId].joint.attr('label/cursor', 'pointer');
                pn.setFireableEvents(Object.keys(pn.transitions[tranId]));
            } else{
                pn.transitions[tranId].joint.attr('body/fill', 'black');
                pn.transitions[tranId].joint.attr('body/cursor', 'default');
                pn.transitions[tranId].joint.attr('label/cursor', 'default');
            }
        });

    };

    SimPNWidget.prototype._setCurrentState = function(newCurrent) {
        this._webgmePN.current = newCurrent;
        this._decoratePetri();
    };
    

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    SimPNWidget.prototype.destroy = function () {
    };

    SimPNWidget.prototype.onActivate = function () {
        this._logger.debug('SimPNWidget has been activated');
    };

    SimPNWidget.prototype.onDeactivate = function () {
        this._logger.debug('SimPNWidget has been deactivated');
    };

    return SimPNWidget;
}); 