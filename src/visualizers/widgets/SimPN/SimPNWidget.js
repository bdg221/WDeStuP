/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Wed Apr 14 2021 10:39:10 GMT-0500 (Central Daylight Time).
 * 
 * Copied from StateMachineJoint
 */



 define(['jointjs', 'css!./styles/SimPNWidget.css'], function (joint) {
    'use strict';

    var WIDGET_CLASS = 'sim-s-m';

    const _ = require("lodash");

    function SimPNWidget(logger, container) {
        
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this._logger.debug('ctor finished');

        
    }

    SimPNWidget.prototype._initialize = function () {
        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);

        this._jointPN = new joint.dia.Graph;
        this._jointPaper = new joint.dia.Paper({
            el: this._el,
            width : width,
            height: height,
            model: this._jointPN,
            interactive: false
        });

        // add event calls to elements
        this._jointPaper.on('element:pointerdblclick', function(elementView) {
            const currentElement = elementView.model;
            console.log("calling attemptFire");
            console.log(currentElement.id);
            self.attemptFire(currentElement.id);
            console.log("back from attemptFire");
            if (self._webgmePN) {
                // console.log(self._webgmePN.id2state[currentElement.id]);
               self._setCurrentState(self._webgmePN.id2transitions[currentElement.id]);
            }
        });

        this._webgmePN = null;
        this._ogPN = null;
    };

    SimPNWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');
    };

    // Petri Net manipulating functions called from the controller
    SimPNWidget.prototype.initPetri = function (petriDescriptor) {
        const self = this;
        console.log(petriDescriptor);
        
        self._ogPN = _.cloneDeep(petriDescriptor);
        self._webgmePN = petriDescriptor;
        //self._webgmePN.current = self._webgmePN.init;
        self._jointPN.clear();
        const pn = self._webgmePN;
        pn.id2transitions = {}; // this dictionary will connect the on-screen id to the transition id
        pn.id2places = {}; // this dictionary will connect the on-screen id to the place id

        // first add the transitions
        Object.keys(pn.transitions).forEach(transitionId => {
            let tran = null;
            let count = 0;
            let color = 'green';
            let cursor = 'default';
            pn.transitions[transitionId].inPlaces.forEach(inPlaceId => {
                if(pn.places[inPlaceId].capacity == 0)
                    color = 'black';
                    cursor = 'pointer';
                count++;
            });
            if(count == 0) color = 'black';
            tran = new joint.shapes.standard.Rectangle({
                position: pn.transitions[transitionId].position,
                size: { width: 30, height: 120 },
                attrs: {
                    label : {
                        text: pn.transitions[transitionId].name,
                        //event: 'element:label:pointerdown',
                        fontWeight: 'bold',
                        cursor: cursor,
                        style: {
                            stroke: 'white',
                            fill: 'white'
                        }
                    },
                    body: {
                        fill: color,
                        strokeWidth: 3,
                        cursor: cursor
                    }
                }
            });
            
            tran.addTo(self._jointPN);
            pn.transitions[transitionId].joint = tran;
            pn.id2transitions[tran.id] = transitionId;
        });

        Object.keys(pn.places).forEach(placeId => {
            let place = null;
            let count = pn.places[placeId].capacity;

            let text = self.getPlaceText(pn.places[placeId]);

            	


            place = new joint.shapes.standard.Circle({
                position: pn.places[placeId].position,
                size: { width: 100, height: 100 },
                attrs: {
                    label : {
                        text: text,
                        //event: 'element:label:pointerdown',
                        fontWeight: 'bold',
                        //cursor: 'text',
                        //style: {
                        //    userSelect: 'text'
                        //}
                    },
                    body: {
                        strokeWidth: 3,
                        //cursor: 'pointer',
                        fillOpacity: 0
                    }
                }
            });
        
            place.addTo(self._jointPN);
            pn.places[placeId].joint = place;
            pn.id2places[place.id] = placeId;
        });

        

        // then create the arcs
        Object.keys(pn.transitions).forEach(tranId => {
            const tran = pn.transitions[tranId];
            Object.keys(tran.inPlaces).forEach(inPlace => {
                tran.jointNext = tran.jointNext || {};
                const link = new joint.shapes.standard.Link({
                    source: {id: pn.places[tran.inPlaces[inPlace]].joint.id},
                    target: {id: tran.joint.id},
                    attrs: {
                        line: {
                            strokeWidth: 2
                        },
                        wrapper: {
                            cursor: 'default'
                        }
                    },
                    labels: [{
                        position: {
                            distance: 0.5,
                            offset: 0,
                            args: {
                                keepGradient: true,
                                ensureLegibility: true
                            }
                        },
                        attrs: {
                        }
                    }]
                });
                link.addTo(self._jointPN);
                tran.jointNext[tran.inPlaces[inPlace]] = link;
            });
            Object.keys(tran.outPlaces).forEach(outPlace => {
                tran.jointNext = tran.jointNext || {};
                const link = new joint.shapes.standard.Link({
                    target: {id: pn.places[tran.outPlaces[outPlace]].joint.id},
                    source: {id: tran.joint.id},
                    attrs: {
                        line: {
                            strokeWidth: 2
                        },
                        wrapper: {
                            cursor: 'default'
                        }
                    },
                    labels: [{
                        position: {
                            distance: 0.5,
                            offset: 0,
                            args: {
                                keepGradient: true,
                                ensureLegibility: true
                            }
                        },
                        attrs: {
                        }
                    }]
                });
                link.addTo(self._jointPN);
                tran.jointNext[tran.outPlaces[outPlace]] = link;
            });
        });

        //now refresh the visualization
        self._jointPaper.updateViews();
        self._decoratePetri();

        if(this.getEnabledTrans().length == 0){
            alert("Deadlock reached. There are no enabled transitions. Please create a better the Petri Net.");
        }

    };

    SimPNWidget.prototype.destroyPetri = function () {

    };

    // SimPNWidget.prototype.fireEvent = function (event) {
    //     const self = this;
    //     const current = self._webgmePN.states[self._webgmePN.current];
    //     const link = current.jointNext[event];
    //     const linkView = link.findView(self._jointPaper);
    //     linkView.sendToken(joint.V('circle', { r: 10, fill: 'black' }), {duration:500}, function() {
    //        self._webgmePN.current = current.next[event];
    //        self._decoratePetri();
    //     });


    // };

    SimPNWidget.prototype.resetPetri = function () {
        const og = this._ogPN;
        console.log("inside reset");
        console.log(this._webgmePN);
        console.log(this._ogPN);
        this._initialize();
        this.initPetri(og);
    };

    SimPNWidget.prototype._decoratePetri = function() {
        const pn = this._webgmePN;
        let count = 0;
        Object.keys(pn.transitions).forEach(tranId => {
            count = 0;
            pn.transitions[tranId].inPlaces.forEach(inPlaceId => {
                if(pn.places[inPlaceId].capacity == 0) count++;
            });
            if (count == 0 && pn.transitions[tranId].inPlaces.size != 0) {
                pn.transitions[tranId].joint.attr('body/fill', 'green');
                pn.transitions[tranId].joint.attr('body/cursor', 'pointer');
                pn.transitions[tranId].joint.attr('label/cursor', 'pointer');
                pn.setFireableEvents(Object.keys(pn.transitions[tranId]));
            } else{
                pn.transitions[tranId].joint.attr('body/fill', 'black');
                pn.transitions[tranId].joint.attr('body/cursor', 'default');
                pn.transitions[tranId].joint.attr('label/cursor', 'default');
            }
        });

    };

    SimPNWidget.prototype._setCurrentState = function(newCurrent) {
        this._webgmePN.current = newCurrent;
        this._decoratePetri();
    };

    SimPNWidget.prototype.getEnabledTrans = function() {
        const pn = this._webgmePN;
        let enabledTrans = [];
        let count = 0;
        Object.keys(pn.transitions).forEach(tranId => {
            count = 0;
            pn.transitions[tranId].inPlaces.forEach(inPlaceId => {
                if(pn.places[inPlaceId].capacity == 0) count++;
            });
            if (count == 0 && pn.transitions[tranId].inPlaces.size != 0) enabledTrans.push(tranId);
        });
        return enabledTrans;
    }

    SimPNWidget.prototype.getPlaceText = function(place) {
        let text = place.name+"\n";
        let count = place.capacity;

        if (count > 12){
            text += "\n"+ count;
            return text;
        }

        for(let i=0; i<count; i++){
            if (i == 2 || i == 5 || i== 8)
                text += "\u25cf \n";
            else
                text += "\u25cf ";
        }
        return text;
    }
    

    /* * * * * * * * Visualizer event handlers * * * * * * * */
    SimPNWidget.prototype.attemptFire = function (nodeId) {
        const pn = this._webgmePN;
        let tran = pn.id2transitions[nodeId];
        console.log("in attemptFire for "+nodeId+ " - "+tran);
        let enabledTrans = this.getEnabledTrans();
        console.log(enabledTrans)
        if (enabledTrans.includes(tran)){
            console.log("firing for node "+tran);
            this.fireTransition(tran);
        }
    };

    SimPNWidget.prototype.fireTransition = function (tranId){
        const self = this;
        let pn = this._webgmePN;
        let text = "";
        let inPlaceId = "";
        let outPlaceId = "";
        
        // take 1 away from capacity of each inPlace and redraw
        
        let inPlaceLength = pn.transitions[tranId].inPlaces.length;
        for(let i=0; i<inPlaceLength; i++){
            inPlaceId = pn.transitions[tranId].inPlaces[i];
            pn.places[inPlaceId].capacity = pn.places[inPlaceId].capacity-1;
            
            text = self.getPlaceText(pn.places[inPlaceId]);
            pn.places[inPlaceId].joint.attr('label/text', text);
            
        }
        //pn.places['/S/C'].capacity = 10;

        // add 1 away capacity of each outPlace and redraw
        let outPlaceLength = pn.transitions[tranId].outPlaces.length;
        for(let i=0; i<outPlaceLength; i++){
            outPlaceId = pn.transitions[tranId].outPlaces[i];
            pn.places[outPlaceId].capacity++;
            text = self.getPlaceText(pn.places[outPlaceId]);
            pn.places[outPlaceId].joint.attr('label/text', text);
        }
        
        self._decoratePetri();
        if(this.getEnabledTrans().length == 0){
            alert("Deadlock reached. There are no enabled transitions. Please restart the Petri Net.");
        }
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    SimPNWidget.prototype.destroy = function () {
    };

    SimPNWidget.prototype.onActivate = function () {
        this._logger.debug('SimPNWidget has been activated');
    };

    SimPNWidget.prototype.onDeactivate = function () {
        this._logger.debug('SimPNWidget has been deactivated');
    };

    return SimPNWidget;
}); 